var assert = require("assert"); // node.js core module

var parser = require("../modelleertaal.js").parser; // jison generated parser

// transfor a string into RanDomCasE for testing the parse for case insensitivity
function rAnDOmCaSe(inputString){
    var outString = '';
    for (var i=0; i < inputString.length; i++) {
        if (Math.random() > 0.5) {
            outString += inputString[i].toUpperCase();
        } else {
            outString += inputString[i]
        }
    }
    return outString;
}

describe('modelleertaal.js - Modelleertaal Parser generated by Jison', function(){
    it('parses assignments', function() {
        assert.equal(typeof parser.parse('t=t'),'object');
    })

    it('parses numbers', function() {
        assert.equal(parser.parse('t=3')[0].right.value,'3');
        assert.equal(parser.parse('t=03')[0].right.value,'03');
        assert.equal(parser.parse('t=3,734')[0].right.value,'3,734');
        assert.equal(parser.parse('t=3.734')[0].right.value,'3.734');
        assert.equal(parser.parse('t=3.7e-5')[0].right.value,'3.7e-5');
    })

    it('parses unary operators', function() {
        assert.equal(parser.parse('t=-3')[0].right.operator,'-');
        assert.equal(parser.parse('t=+3')[0].right.operator,'+');
        assert.equal(parser.parse('t=!3')[0].right.operator,'NOT');
        assert.equal(parser.parse('t=niet 3')[0].right.operator,'NOT');
    })

    it('parses unicode squared/cubed (²) operator (not as part of IDENT)', function() {
        assert.equal(parser.parse('t=v²')[0].right.type,'Binary');
        assert.equal(parser.parse('t=v³')[0].right.type,'Binary');

    })

    it('parses math expressions', function() {
        assert.equal(typeof parser.parse('t=t+2*3-5*(6*7)-5^3'),'object');
        assert.equal(typeof parser.parse('t=t²+2*3-5*(6*7)-5³'),'object');
    })

    it('parses functions', function() {
        assert.equal(parser.parse('t=somefunction(x)')[0].right.func,'somefunction');
    })

    it('parses stop', function() {
        assert.equal(parser.parse('stop')[0].type,'Stop');
    })

    it('parses print', function() {
        assert.equal(parser.parse('print(y)')[0].type,'Print');
        assert.equal(parser.parse('print(y)')[0].varname,'y');
    })

    it('parses pi', function() {
        assert.equal(parser.parse('t = pi')[0].right.type,'Number');
        assert.equal(parser.parse('Pin = 100')[0].left,'Pin');  // not Pi!
        assert.equal(parser.parse('t = π')[0].right.type,'Number');
    })

    it('parses if statements', function() {
        assert.equal(parser.parse('als waar dan stop eindals')[0].type,'If');
        assert.equal(parser.parse('als waar dan stop eindals')[0].then[0].type,'Stop');

    })

    it('parses identifiers with numbers in name', function() {
        //console.log((parser.parse('ditiseenvariabele = 0')[0]));
        assert.equal(parser.parse('ditiseenvariabele = 0')[0].left,'ditiseenvariabele');
        assert.equal(parser.parse('dit1 = 0')[0].left,'dit1');
        assert.equal(parser.parse('l33th4x0r = 0')[0].left,'l33th4x0r');
    })

    it('parses identifiers with unicode', function() {
        assert.equal(parser.parse('σ=4.2')[0].left,'σ');
        assert.equal(parser.parse('foo_σ_bεr=3.14')[0].left,'foo_σ_bεr');
    })

    it('parses booleans', function() {
      assert.equal(parser.parse(rAnDOmCaSe('t = waar'))[0].right.type,'Boolean');
      assert.equal(parser.parse(rAnDOmCaSe('t = waar'))[0].right.value,'true');
      assert.equal(parser.parse(rAnDOmCaSe('t = onwaar'))[0].right.type,'Boolean');
      assert.equal(parser.parse(rAnDOmCaSe('t = onwaar'))[0].right.value,'false');
    })

    it('parses lists', function() {
        assert.equal(parser.parse('t = 1;2')[0].right.type,'List');
        assert.equal(parser.parse('t = min(1;2)')[0].right.type,'Function');
        assert.equal(parser.parse('t = (1;2)')[0].right.type,'List');
      })

    it('parses keywords case insensitive', function() {

        // make RanDomCasE strings and test
        for (i = 0; i < 20; i++) {
            assert.equal(parser.parse(rAnDOmCaSe('t = waar'))[0].right.type,'Boolean');
            assert.equal(parser.parse(rAnDOmCaSe('t = onwaar'))[0].right.type,'Boolean');
            assert.equal(parser.parse(rAnDOmCaSe('als waar dan stop eindals'))[0].type,'If');
            assert.equal(parser.parse(rAnDOmCaSe('als waar dan stop eindals'))[0].then[0].type,'Stop');
        }
    })

    it('parses identifiers case sensitive', function() {
        //console.log((parser.parse('ditiseenvariabele = 0')[0]));
        assert.notEqual(parser.parse('ditiseeNvariabele = 0')[0].left,'ditiseenvariabele');
        assert.equal(parser.parse('DitT1 = 0')[0].left,'DitT1');
        assert.equal(parser.parse('DitT1abcD = 0')[0].left,'DitT1abcD');
    })

    it('parses names with parts of keywords in the name', function() {
        //console.log((parser.parse('ditiseenvariabele = 0')[0]));
        assert.equal(parser.parse('ditstop = 0')[0].left,'ditstop');
        assert.equal(parser.parse('nietwaar = 0')[0].left,'nietwaar');
    })

    it('parses names with { } [ ] | and _ in names', function() {
        assert.equal(parser.parse('t_0\[\]\{\}\| = 0')[0].left,'t_0\[\]\{\}\|');
    })

});

describe('modelleertaal.js - Patched parser injects line numbers into AST', function(){
    it('injects line numbers', function() {
        assert.equal(parser.parse('t=t+3')[0].lineNo, 1);
        assert.equal(parser.parse('t=t+3')[0].right.lineNo, 1);
        assert.equal(parser.parse('\n\nt=t+3')[0].lineNo, 3);
    })
});
